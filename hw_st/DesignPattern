
#Chapter 01. 들어가기
	1. 절차지향 -> 객체지향
	2. 수많은 IF~ELSE 반복문의 향연에서 벗어나라. 
		-> 클래스가 많이 생성되어 구조는 다소 복잡해졌지만, 요구사항의 변경시 유지보수가 용이해지며 유연한 구조를 갖게된다.


#Chapter 02. 객체지향
	1.절차지향
		문제점 - 새로운 요구사항의 발생으로 인한 수정 시, 한 곳을 수정하면 다른 곳에서 문제가 발생하는 악순환 발생
	
	2.객체지향
		프로그램의 규모가 작을 때에는 절차지향방식보다 복잡한 구조를 갖게된다.
		하지만, 객체지향에서는 해당 객체의 데이터를 변경하더라도 다른 객체에는 영향을 주지 않는다.
	
		인터페이스 - 객체를 사용하기 위한 일종의 명세나 규칙. 실제 객체가 기능을 어떻게 구현하는지에 대한 내용은 포함안함.
	
	3.객체의 책임과 크기
		객체가 제공하는 기능의 개수가 적다 -> 객체가 갖는 책임이 작다.
		한 객체에 기능이 많아지면 절차 지향적인 구조를 갖게된다. <--> 단일책임원칙(Single Responsibilty Principle; SRP)
		한 객체가 다른 객체를 생성하거나 다른 객체의 메소드를 호출할 때 => 의존
		
	4. 의존
		4.1 의존의 양면성
			a클래스 <-- b클래스 <-- c클래스 와 같은 의존의 경우,
			a클래스의 변경은 b와 c클래스에 영향을 주게된다.
	
	5. 캡슐화
		5.1 한 곳의 변화가 다른곳에 미치는 영향을 최소화한다.
			 내부 기능 구현이 변경되더라도 기능을 사용하는 코드는 영향을 받지 않도록 만들어준다.
		
		5.4 캡슐화를 위한 두 개의 규칙
			1. Tell, Don't Ask
				데이터를 물어보지 않고, 기능을 실행해라
				
			2. 데미테르의 법칙
				1. 메소드에서 생성한 객체의 메소드만 호출
				2. 파라미터로 받은 객체의 메소드만 호출
				3. 필드로 참조하는 객체의 메소드만 호출
				
				ex) public void processSome(Member menber){
						if(member.getDate().getTime() < ...){ //데미테르 법칙 위반
							...
						}
						
					}
				
				*데미테르의 법칙을 지키지 않는 전형적인 증상 2가지
					1. 연속된 get메소드 호출
					2. 임시 변수의 get 호출이 많음
				
			    **캡슐화는 내부 구현에 대해 유연함을 제공해준다.
			    
			    
#Chapter 03. 다형성과 추상타입		
	3.3 변화하는 부분을 추상화하기
		1. 변화되는 부분을 추상화하기
			=> 요구사항이 바뀔 때 변화하는 부분은 이후에도 변경될 소지가 많다.
				이를 추상타입으로 교체하면 향후 변경에 유연하게 대처 가능
			*추상화가 되어있지 않은 코드는 주로 동일 구조를 갖는 if-else블록으로 드러난다.
			
	3.4 인터페이스에 대고 프로그래밍하기
		1. 여기서의 인터페이스는 기능을 정의한 인터페이스를 사용하라는 의미
		추상화과정은 변화가 발생하는 곳에서부터 시작된다.
		하지만, 인터페이스를 사용할 때는 변화가능성이 높은 경우에 한해서 사용해야 한다.
		
	3.6 인터페이스와 테스트
		사용할 대상을 인터페이스로 추상화하면 만들 수 있는 
		Mock객체(가짜,모의)를 사용하여 테스트가 가능하다. (Mockito / jmock과 같은 프레임워크를 이용)
		

#Chapter 04. 재사용 : 상속보단 조립
	*객체지향의 주요 특징 : 상속을 통한 상위클래스의 메소드 재사용이 가능하다. 
		하지만 상위 클래스의 구현기능을 상속하여 사용할 경우 몇가지 문제점이 발생할 수 있다.
		
	1. 상속을 통한 재사용의 단점
		1.1 단점 1. 상위클래스 변경의 어려움
			어떤 클래스를 상속받는다 => 그 클래스에 의존한다
			계속되는 상위클래스의 상속은 모든 클래스들을 한 개의 거대한 단일구조처럼 만드는 결과를 초래.
			
		1.2 단점2.클래스의 불필요한 증가
			자바는 다중상속이 불가하기 때문에, 여러 기능의 조합이 필요한 경우 불필요하게 클래스가 계속 증가한다.
			 
		1.3 단점3.상속의 오용문제
			ex) ArrayList를 상속받은 Container라는 클래스에서 put이라는 메소드를 정의.
				put은 size를 정의한 하나의 ArrayList에서 사용됨. 
				하지만 개발자들이 put을 사용하지 않고, 직접적으로 ArrayList의 add메소드를 사용하여
				정의한 size를 초과하여 넣을 수 있게되는 문제가 발생할 수 있다.
			
	2. 위의 단점들의 해결방안 : 조립을 위한 재사용
		1.객체조립 : 여러 객체를 묶어서 더 복잡한 기능을 제공하는 객체를 만들어 내는 것
						조립을 이용하면 불필요한 클래스 증가를 방지
						ex) 필드에서 다른 객체를 참조하는 방식
		*조립을 통한 재사용의 단점 : 상대적으로 런타임 구조가 복잡해짐... 하지만 장점이 더 큼
		
		2.1 위임
			객체조립을 통해 다른객체에 처리를 위임시키는거 
			ex) 다른 객체에 위임한 후 메소드 요청
			
		2.2 그럼 상속은 대체 언제쓰냐 장점이 무엇인가
			상속을 사용할 때는 재사용이라는 관점이 아닌 기능의 확장 관점에서..
			+ 명확한 IS-A관계가 성립되어야 한다.
			=> 상위클래스의 기본기능은 기대로 유지하면서 하위로 내려갈수록 그 기능을 확장해나간다.
			ex) UI위젯
	

#Chapter 05. 설계 원칙: SOLID
	---------------------------------------------------------
	1. 단일 책임 원칙(Single Responsibility principle; SRP)
	2. 개방-폐쇄 원칙(Open-closed principle; OCP)
	3. 리스코프 치환 원칙(Liskov substitution principle; LSP)
	4. 인터페이스 분리 원칙(Interface segregation principle; ISP)
	5. 의존 역전 원칙(Dependency inversion principle; DIP)
	---------------------------------------------------------
	
	1. 단일 책임 원칙(Single Responsibility principle; SRP)
		클래스는 하나의 책임을 가져야 한다. 
		1.1 단일 책임 원칙 위반이 불러오는 문제점
			=> 읽어오는 데이터 타입의 변화 하나만으로 연쇄적으로 다른 코드의 변화도 야기시킨다. (ex. 데이터를 읽어오는 책임 / 화면에 뿌려주는 책임 두가지를 같이 갖고 있기 때문에)
		
		1.2 책임이란 변화에 대한 것
			서로 다른 이유로 바뀌는 책임들이 한 클래스에 함께 포함되어 있다면 이 클래스는 단일 책임 원칙을 어기고 있다.
			변화하는 부분 => 책임의 단위
		
		
	2. 개방-폐쇄원칙(Open-closed principle; OCP) //(?캡슐화와의 연관성)
		*확장에는 열려있어야 하고, 변경에는 닫혀있어야 한다.
			=> 기능을 변경/확장 할 수 있으면서, 그 기능을 사용하는 코드는 수정하지 않는다.
				=> 어떻게? : 추상화!! (***변화되는 부분을 추상화하여 변화를 고정시킨다.)
								또다른 방법은 상속! (변화되는 부분을 오버라이딩하여 하위클래스에서 기존 기능을 확장)
								
		2.1 개방 폐쇄 원칙이 깨질 때의 주요 증상
			1. 다운캐스팅
				다운캐스팅 후 실행하는 메소드가 변화대상인지 고려한 뒤, 객체마다 다르게 동작할 가능성이 높다면 이 메소드를 추상화하여야한다.
				
			2. 비슷한 if-else블록이 존재
				요구사항의 추가가 발생 시, 새로운 if-else블록이 생성 => 이를 막기 위해 바뀌는 부분을 추상화한 뒤 이를 사용하는 구조로 변경
			
			**변화가 예상되는 것을 추상화해서 변경의 유연함을 얻도록 해주자.
				변화가 발생하는 부분 => 추후에도 변화가 일어날 것 같은지 판단하는 능력... => 일어난다면 추상화 or 캡슐화 
			
			
	3. 리스코프 치환 원칙(Liskov substitution principle; LSP)
		**상위타입의 객체를 하위타입의 객체로 치환해도 상위타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
		***개방폐쇄원칙을 받쳐주는 다형성에 관한 원칙 => 상속을 사용해서 좋은지 나쁜지 판단할 때 LSP를 사용
		***LSP는 상속에 대해 엄격함을 적용하는 것. 올바른 상속이냐 라는 질문에 답을 해줄 수 있는 원칙
		***리스코프 치환 원칙이 왜 중요한가?
				1. 서브클래스 인스턴스를 파라미터로 전달 했을 때 메소드가 이상하게 작동 할 수 있다.
				2. 슈퍼클래스에 대해 작성된 단위테스트가 서브클래스에 대해서는 작동되지 않을 것이다.

		3.1 리스코프 치환 원칙을 지키지 않을 때의 문제
			ex)직사각형-정사각형 문제
			직사각형-정사각형은 ISA관계를 충족시키지만, 객체의 행위는 상호간의 일관성이 없다. 행위적으로 정사각형은 직사각형이 아니다.
		
		3.2 리스코프 치환 원칙은 기능의 명세와 확장에 대한 것
			*흔히 발생하는 위반 사례
				1. 명시된 명세에서 벗어난 값을 리턴
				2. 명시된 명세에서 벗어난 익셉션 발생
				3. 명시된 명세에서 벗어난 기능 수행
				
	//지금까지의 공통적인 이야기는  변화에 유연하게 대처할 수 있도록 설계하는 것이 중요하다.
		단일책임원칙을 바탕으로 변화나 요구사항이 추가되는 부분에서 
		이 변경으로 인해 야기될 수 있는 다른 곳의 변경을 최소화하여 기능 변경/확장을 쉽게 할 수 있도록 하는 것 뿐 아니라, 
		변경되는 부분이 추후에도 변경될 수 있는지에 대한 가능성을 캐치하는 능력을 키우고,
		만약 추후 변경가능성이 높다면 이를 추상화하여 변화를 고정시켜서 마찬가지로 향후 변경에 유연하게 대처가 가능하도록 해야한다.
		
		**타입을 확인하는 기능(ex. instanceof)을 사용하는 것은 전형적으로 리스코프 치환원칙을 어길때 발생하는 증상. => 하위타입을 대체할 수 없다는 뜻
			=> 이럴 때는 보통 추상화가 덜 되었기 때문이므로 요구사항의 변경이 발생한 부분을 판단하는 메소드를 상위타입에 추가하고 하위타입에서 재정의하여 리스코프 치환원칙을 지킬 수 있도록 한다.
		
		***리스코프 치환 원칙을 지키지 않으면 기능의 확장 시 점점 더 확장이 어렵게된다. 웬만하면 지키자.
	
	
	4. 인터페이스 분리 원칙(Interface segregation principle; ISP)
		*클라이언트는 자신이 사용하는 메소드에 의존해야 한다. => 클라이언트 입장에서 인터페이스를 분리하라!
		
		**자바에서는 JVM이 .class파일을 로딩하는 과정에서 링크과정이 동적으로 발생되기 때문에
		C++에서 발생하는 '사용하지 않는 인터페이스 변경에 의해 발생하는 소스 재컴파일' 문제가 발생하지는 않는다.
		하지만 용도에 맞게 인터페이스를 분리하는 것은 단일책임원칙과도 연결된다. 이게 잘 지켜져야만 재사용성도 높아지고 변경에 대한 여파도 최소화할 수 있다.
	
		각 클라이언트가 사용하는 기능을 중심으로 인터페이스를 분리해라... 결론은 기능관점에서 인터페이스를 설계해라. 라는 말..같다..
		
	5. 의존 역전 원칙(Dependency inversion principle; DIP)
		***저수준 모듈이 변경되더라도 고수준 모듈은 변경되지 않는 것.
		고수준 모듈이 저수준 모듈을 사용한다는 것은 고수준 모듈이 저수준 모듈에 의존적이 된다는 것인데, 어떻게 저수준이 고수준을 의존하게 만든다는걸까? => 추상화!!
		고수준과 저수준 모듈 모두가 추상화타입에 의존하게 함으로써, 고수준 모듈의 변경 없이 저수준 모듈을 변경할 수 있는 유연함을 갖게 된다.
		***이 때, 추상화 타입인 인터페이스는 고수준 모듈의 입장에서 만들어진다 => 저수준 모듈이 고수준 모듈에 의존하게 된다.
		***의존역전원칙은 리스코프 원칙과 함께 개방-폐쇄원칙의 기반이 되어준다.	  
		***하지만 소스코드는 의존적일지라도 런타임에서는 의존이 역전되지 않는다.
		
		5.4 의존역전원칙과 패키지
			타입의 소유도 역전시킨다.
			원래는 저수준 모듈이 타입을 소유하고 있었지만, 의존역전원칙을 적용함으로서 타입을 고수준 모듈이 소유하게 되고 이는 곧 독립적으로 배포할수 있도록 만들어준다,...?
			
			
			
	*****SOLID 원칙정리
	SOLID원칙을 한마디로 정의하면, 변화에 유연하게 대처할 수 있는 설계 원칙!
	
	*단일책임원칙과 인터페이스 분리 원칙은 객체가 커지지 않도록 막아주고 많은 기능을 갖지 않게 해준다 => 재사용성이 높아지고 기능 변경도 보다 용이해진다.
	*리스코프 치환원칙과 의존역전원칙은 개방폐쇄 원칙을 지원한다.
	*개방폐쇄 원칙은 변화되는 부분은 추상화 => 의존역전원칙
						/ 다형성(상속)을 이용하여 기능확장을 하면서도 기존코드를 수정하지 않도록 해준다. => 다형성을 도와주는 리스코프 치환 원칙
						
	
#Chapter 06. DI와 서비스 로케이터
	*소프트웨어가 크게 두 개의 영역으로 나뉘어진다.
		- 고수준 정책 및 저수준 구현을 포함한 어플리케이션 영역
		- 이 어플리케이션이 동작하도록 각 객체들을 연결해주는 메인 영역
		
	**메인영역
		어플리케이션 영역에서 사용될 객체를 생성한다.
		각 객체 간의 의존관계를 설정한다.
		어플리케이션을 실행한다.
		=> 메인영역은 어플리케이션 영역에 의존적이다.
			어플리케이션에서 사용할 객체를 교체하기 위해 메인 영역의 코드를 수정하는 것은 어플리케이션영역에는 어떠한 영향도 끼치지 않는다.
			
		
		2. DI를 이용한 의존 객체 사용
			*콘크리트 클래스를 직접 사용해서 객체생성 => 의존역전원칙 위반 => 개방 폐쇄원칙 위반 => 변화에 경직된 코드
			*서비스 로케이터를 사용 시, 서비스 로케이터를 통해서 의존객체를 찾게 되는데...단점이 존재한다. 뒤에서 설명.
			
			=> 이러한 단점을 보완한 것이 DI이다. 
			필요한 객체를 직접 생성하거나 찾지 않고 외부에서 넣어주는 방식
			
			DI를 통해서 의존객체를 관리할 때는 객체를 생성하고 각 객체들을 의존관계에 따라 연결해 주는 조립기능이 필요하다.
			=> Spring framework가 바로 객체를 생성하고 조립해주는 기능을 제공하는 DI 프레임워크이다.
			
			2.1 생성자 방식과 설정메소드 방식
				**의존하는 객체를 전달받을 수 있는 두 가지 방식 
					1) 생성자방식
						- 생성자를 통해서 의존객체를 전달받는 방식으로서, 전달받은 객체를 필드에 보관한 뒤 메소드에서 사용
					
					2) 설정메소드 방식
						- 메소드를 이용해서 의존객체를 전달받는다. 
						- 파라미터로 전달받은 의존객체를 필드에 보관한 뒤, 다른메소드에서는 필드를 사용해서 의존객체의 기능을 실행
						
				*의존객체 주입이 완료되면, 조립기는 생성자와 설정메소드를 이용해서 의존객체를 알아서 전달
			   
			  ***각 방식의 장단점
			  	*생성자방식
			  		- 객체를 생성하는 시점에 필요한 모든 의존객체를 준비할 수 있으며 의존객체가 정상인지 확인할 수 있다.
			  		- 의존 객체가 먼저 생성되어 있어야 한다.
				
				*설정메소드 방식
					- 객체를 생성한 뒤에 의존객체를 주입한다.
					- 객체가 나중에 생성된다면 설정메소드방식을 사용해야 한다.
					- 의존할 객체가 많을 경우,메소드 이름을 통해 코드 가독성을 높일 수 있다.
					
			2.2 DI와 테스트
				***DI는 의존 객체를 Mock객체로 쉽게 대체할 수 있도록 도와서 쉬운 단위테스트가 가능하다.
				 
			2.3 스프링 프레임워크 예
				*대표적 DI 프레임워크
				생성자 방식과 설정 메소드 방식을 모두 지원하며 XML파일을 이용하여 객체생성과 조립을 설정한다.
				스프링 3.x버전부터는 XML파일을 자바 코드 기반으로 설정할 수도 있다.
				
		3. 서비스 로케이터를 이용한 의존 객체 사용
			**안드로이드 같은 환경적 제약으로 인해 DI패턴을 적용할 수 없는 경우 서비스 로케이터를 사용하여 의존객체를 사용한다.
				
			3.1 서비스 로케이터의 구현
				*ServiceLocator - 어플리케이션에서 필요로하는 객체를 제공하는 책임을 갖는다.
										의존대상이 되는 객체별로 제공메소드를 정의한다. 의존객체가 필요한 곳에서 메소드를 이용하여 필요한 객체를 구한 뒤 기능 실행한다.
										서비스 로케이터는 어플리케이션 영역에 위치하게 되며, 
										메인영역에서는 서비스 로케이터가 제공할 객체를 생성하고 이 객체를 이용해서 서비스 로케이터를 초기화 해준다.
			
			*객체등록방식의 서비스 로케이터 구현
				서비스 로케이터 생성할 때 사용할 객체를 전달한다.
				인스턴스를 지정하고 참조하기 위한 static 메소드를 제공한다.
				
				*객체등록방식의 장점은 서비스로케이터 구현이 쉽다는 것.
				  => 사용코드에서 서비스 로케이터의 get메소드를 통해 사용할 객체를 구하기만 하면 된다. 
				  
			* 상속을 통한 서비스 로케이터 구현
			   객체를 구하는 추상메소드를 제공하는 상위 타입 구현
			   상위 타입을 상속받은 하위타입에서 사용할 객체 설정
			   => ServiceLocator는 추상클래스. / .getInstance()를 사용해서 ServiceLocator객체를 구하고 의존객체를 구한다.
			   
			   ***ServiceLocator클래스를 상속받은 클래스의 객체를 생성할때마다 ServiceLocator 클래스의 static필드인 instance가 참조하는 객체가 변경됨.
			   		이를 막기 위해서 instance가 null이 아닐 경우에 Exception을 발생시키는 방법이 있다.
			   		
			*제네릭/템플릿을 이용한 서비스 로케이터 구현
				**서비스 로케이터의 단점은 인터페이스 분리 원칙을 위반한다는 점.
					하지만, 의존객체마다 서비스로케이터를 작성하면 인터페이스가 분리되는 효과는 얻을 수 있지만, 동일한 구조의 서비스 로케이터 클래스를 중복해서 만드는 문제를 야기
					=> 제네릭기반의 Map방식을 활용하여 구현하면 중복된 코드를 피하면서 인터페이스를 분리하는 효과를 낼 수 있다.
			   
			***결론...
			서비스 로케이터는 DI 변경의 유연함을 떨어뜨리는 문제가 있기 때문에, 서비스 로케이터보다는 DI를 사용하자...
			
			
#Chapter 07. 주요 디자인 패턴
	*디자인 패턴 : 반복적으로 사용되는 설계는 일정한 패턴을 갖게 된다. // GOF패턴 + Null객체 패턴에 대해 알아보자.
	
	2. 전략(Strategy)패턴
		
		ex)과일매장의 가격계산모듈에 할인정책을 추가한다고 하자.
		첫손님 10%할인과 덜 신선한 것 20%할인정책이 존재한다고 가정하자. If-else문으로 이루어져 있다.
		만약 여기에 또 다른 정책이 추가된다면 또 if-else문이 반복으로 생성된다.
		
		=> 이는 점진적으로 코드분석과 메소드 수정을 어렵게 만든다.
		==> 따라서, 하나의 인터페이스로 여러 할인정책을 추상화하고, 각 콘크리트 클래스는 상황에 맞는 할인 계산 알고리즘을 제공.
		
		***이와 같이 특정 콘텍스트에서 알고리즘을 별도로 분리하는 설계방법이 전략패턴이다.
				
	3. 템플릿 메소드 패턴
		
		**프로그램을 구현하다보면 실행과정이 동일하고 일부의 구현만 다른 경우가 존재한다.
		이렇게 실행 과정/단계는 동일한데 각 단계 중 일부의 구현이 다른 경우에 사용할수 있는 패턴 => 템플릿 메소드 패턴
		
		동일한 구조는 상위타입에 두고, 하위 타입에서 일부 단계를 구현하도록 구성할 수 있다.
		
		종류 2가지 - 실행 과정을 구현한 상위 클래스
					  - 실행과정의 일부 단계를 구현한 하위 클래스
					  
		3.1 상위클래스가 흐름 제어 주체
		
		** 일반적으로 하위타입이 상위타입의 기능을 재사용할지 여부를 결정
			하지만, 템플릿 메소드 패턴에서는 상위 타입의 템플릿 메소드가 모든 실행 흐름을 제어하고, 하위 타입의 메소드는 템플릿 메소드에서 호출되는 구조를 갖게 된다.
			이때 호출되는 메소드는 하위타입에서 재정의되어야하므로 private이 아닌 protected의 범위를 가져야 한다.
			=> 이와 같이 상위 클래스에서 실행 시점이 제어되고, 기본 구현을 제공하면서, 하위클래스에서 알맞게 확장할 수 있는 메소드 => 훅(hook) 메소드
			
		3.2 템플릿 메소드와 전략패턴의 조합
			=> 상속이 아닌 조립의 방식으로 템플릿메소드 패턴을 활용
			템플릿 메소드를 실행할 때 변경되는 부분을 실행할 객체를 파라미터를 통해 전달받는 방식으로 구현되어 있다.
			
			즉, 앞선 템플릿 메소드는 하위타입에서 재정의할 메소드를 호출한다면,
				이 조합의 메소드는 파라미터로 전달받은 객체의 메소드를 호출한다.
				
			**상속이 아닌 조립의 방식을 활용한다면 상속기반과 비교하여 유연함을 갖는다.
			상속기반은 클래스가 불필요하게 증가할 수도 있으며, 런타임에 구현객체를 변경할 수 없다. 
			하지만 조립을 사용하면 메소드에서 사용할 객체를 교체할 수 있는 장점이 있다.
			
			
	4. 상태 패턴
		**조건문이 상태에 따라 동일한 기능 요청의 처리를 다르게 할 때 사용하는 패턴 => 상태(State) 패턴
		***상태를 별도의 타입으로 분리하고, 각 상태별로 알맞은 하위 타입을 구현 => 상태객체가 기능을 제공한다.
		
		***상태패턴의 장점 : 새로운 상태가 추가되더라도 콘텍스트 코드가 받는 영향은 최소화된다.
		영향 최소화 -> 복잡도 증가안함 -> 유지보수 용이 -> 상태별 동작 수정 쉽다
		
		4.1 상태변경은 누가?
			주체는 콘텍스트나 상태 객체 둘 중 하나.
			*콘텍스트에서 상태를 변경하는 방식 : 비교적 상태 개수가 적고 상태 변경 규칙이 거의 바뀌지 않는 경우
			*상태 객체에서 콘텍스트의 상태를 변경하는 방식 : 콘텍스트에 영향을 주지 않으면서 상태를 추가하거나 상태 변경가능
			
	
	5. 데코레이터 패턴
		 - 데코레이터 패턴은 객체의 추가적인 요건을 동적으로 추가한다.
		 - 데코레이터는 서브 클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다.
		 - 한 객체를 여러 개의 데코레이터로 감쌀 수 있다.
		 - 기존 코드를 수정하지 않고도 데코레이터를 조합하는 방식으로 기능을 확장할 수 있다. 
		 => 단일책임원칙을 지킬 수 있도록 만들어준다.
	
	 	※ 단점
		 - 데코레이터 패턴을 이용해 디자인을 하다 보면 잡다한 클래스가 많아 질 수 있다.
		 - 겹겹이 애워싼 객체의 정체를 알기가 힘들다. 코드만으로는 기능이 어떻게 동작하는지 이해하기 어려워진다.
		 - 상속을 통해 확장할 수도 있지만, 디자인 유연성 면에서는 별로 좋지 않다.
		 - 정의된 메소드가 증가할 경우 그만큼 데코레이터의 구현도 복잡해진다.	
			
		ex)스타벅스커피 예시 
		http://warmz.tistory.com/757
		
		
	6. 프록시 패턴  -예제 한번 작성해보기
		Proxy의 사전적 의미는 대리, 대리권 이라는 뜻을 가지고 있다. 
		실제 사용하려는 객체를 대신해서 프록시 객체가 실제 객체의 생성이나 접근 등을 제어할 수 있도록 해주는 패턴이다. 
		주로 원래 객체의 접근제어를 목적으로 이용된다.
		
		 필요한 순간에 실제 객체를 생성해주는 프록시 => 가상 프록시
		 실제 객체에 대한 접근 권한을 검사할 필요가 있을때 프록시 => 보호 프록시
		 다른 프로세스에 존재하는 객체에 접근할 때 사용 => 원격 프록시
		 
		 6.1 프록시 패턴을 적용할 때 고려할 점
		 	가상 프록시는 필요한 순간에 실제 객체를 생성하는 경우가 많다. -> 가상 프록시에서 실제 생성할 객체의 타입을 사용하게 된다.
		 	
		 	**상속방식의 프록시는 객체를 생성하는 순간 실제 객체가 생성되기 때문에 가상 프록시를 구현하기는 적합하지 않다.
		 	
		 	
	7. 어댑터 패턴
		*클라이언트가 요구하는 인터페이스와 재사용하려는 모듈의 인터페이스가 일치하지 않을 때 사용할 수 있는 패턴
		 ﻿- 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환한다. 
		 - 어댑터를 이용하면 인터페이스의 호환성 문제 떄문에 같이 쓸 수 없는 클래스를 연결해 쓸 수 있다.
		 	그러나 어댑터 클래스의 대부분의 코드를 구현해야 하기 때문에 효율적이지 못하다.
	
	
	8. 옵저버 패턴 ex)예시 - 웹사이트의 상태를 확인 후 상태이상 시 메일로 통지해주는 시스쳄
		**한 객체의 상태변화를 정해지지 않은 여러 다른 객체에 통지하고 싶을 때 사용되는 패턴
		장점 : 주제 클래스 변경 없이 상태 변경을 통지 받을 옵저버를 추가할 수 있다.
		
		8.1 옵저버 객체에게 상태 전달 방법	
			*지금까지는 주제 객체가 옵저버 호출 시 상태값을 옵저버에 전달하고,
				옵저버는 파라미터로 전달받은 상태값을 사용했다.
			하지만 특정 상황에 따라서는 옵저버 객체에서 콘크리트 주제 객체에 직접 접근할 수도 있다.
			ex)옵저버 객체의 메소드 예시 
				if(status.isFault() && statusChecker.isContinuousFault()){...}
					status는 옵저버가 파라미터로 전달받은 상태값이고
					그 다음 부분은 직접 콘크리트 주제객체에 접근한다.
					=> 옵저버 클래스는 필요에 따라 주제 객체 클래스에 의존한다.
		
		8.2 옵저버에서 주제 객체 구분
			*한 옵저버를 여러 주제 객체에 등록하는 경우, 각 주제 객체를 구분할 수 있는 방법이 필요하다.
			=> 구분방법을 관리하는 추상클래스를 제공하여 코드중복을 막을 수 있다.
			
		8.3 옵저버 패턴 구현의 고려사항
			1.주체 객체의 통지 기능 실행 주체
				주제 객체의 상태가 바뀔 때마다 옵저버에게 통지를 해주어야 한다면, 주제 객체에서 직접 통지하는 것이 구현에 유리.
				하지만, 한 개 이상의 주제 객체의 연속적 상태변경 이후에 옵저버에게 통지해주어야 한다면
				주제객체가 아닌 주제 객체의 상태를 변경하는 코드에서 통지기능을 실행하도록 하는 것이 통지시점을 관리하기에 더 수월하다.
				
			2. 통지 시점에 주제 객체의 상태에 결함이 없어야 한다.
				상태 변경과 통지 기능에 템플릿 메서드 패턴을 적용하여,
				상태변화를 마무리 한 후 에 옵저버 객체가 상태값을 접근하게 한다.	

		
	9. 미디에이터(Mediator) 패턴 (중재자)
		** '객체 간의 결합을 책임지는 객체'
		
		각 객체들이 직접 메시지를 주고받으며 의존을 직접연결되어있는 구조 => 결합도가 너무 높아지는 문제점 발생. 
		따라서, 중간에 중계 역할을 수행하는 미디에이터 객체를 두고 미디에이터를 통해서 각 객체들이 간접적으로 의존하도록 설정하는 것.
		또한, 미디에이터 클래스를 추상 클래스로 만들어서 클래스를 재사용하면서 필요한 기능을 확장할 수도 있다.
		
		단점 : 협업클래스의 개수가 증가할수록 미디에이터의 코드는 복잡해지고 유지보수가 어려워질 수 있다.
		
	
	10. 파사드(Facade) 패턴 ex)어항청소패턴 씻고닦고등등..
		*서브시스템을 감춰주는 상위 수준의 인터페이스를 제공하는 것... 이미 자주 사용하고 있는 패턴 중 하나이다. 
		클라이언트는 캡슐화된 프로세스 내의 동작을 알 필요 없이 해당 인터페이스가 요구하는 정보만 넣어서 호출하면 원하는 결과를 얻을 수 있도록 한다. 
		한 마디로 복잡한 클래스들과 패키지들을 어떤 단순한 인터페이스 객체 뒤에 감추는 것이다. 
		
		파사드 패턴은 어떻게 보면 어댑터 패턴하고도 비슷하나 Adaptation할 기능의 규모가 좀 더 큰 경우에 보다 적합하다고도 할 수 있다.
		또한, 클래스와 비교해 보면, 파사드는 인터페이스와 유사하다. 파사드를 통해 서브시스템의 상세 구현을 캡슐화하고, 이 상세구현이 변경되더라도
		파사드를 사용하는 코드에 주는 영향을 줄일 수 있게 된다.
		
		
	11. 추상 팩토리(Abstract Factory) 패턴
		*객체생성 책임을 분리하는 패턴
		 - 팩토리 : 객체 생성을 처리하는 클래스. 
		 - 추상 팩토리 패턴의 본질은 "관련된 객체들의 집단(family)을 생성하는 인터페이스를 제공하되, 생성되는 객체의 구체적인
		    클래스를 알 필요 없다는 것"이다.
		 - Factory를 사용하는 Client가 많을 경우 여러 클래스에서 사용할 수 있다.
		 - 생성할 클래스가 변하면 인터페이스 메서드 전체를 수정해야 하는 단점이 있으나 다수의 클래스가 존재하고 상황에 맞게
		     적당한 클래스를 골라서 생성할 때 유용하다.
		 - 객체 생성을 위한 메소드 실행을 위해 객체 인스턴스를 만들지 않아도 된다.

		*팩토리가 생성하는 객체가 늘 동일한 상태일 경우 프로토타입 방식으로도 구현할 수 있다.
			처음에 원형 객체를 등록하고 객체 생성 요청이 있으면 원형 객체를 복제해서 생성한다.
			
	
	12. 컴포지트(Composite) 패턴 ex) 장비들의 전원제어관리. 장비그룹=> 각층장비그룹 => 전사장비그룹
		*복합체 패턴 => 단일 객체와 객체들이 모인 컨테이너 객체를 구분없이 한종류처럼 다룬다.
		각각의 단일 객체와 복합체, 부분과 전체를 한 개의 인터페이스로 추상화하여 사용자는 단일 객체든 복합체든 상관없이 똑같이 다룰 수 있는 편리함을 부여하는 패턴. 
		복합체는 복합체를 포함할 수도 있어서 트리 구조로 객체를 표현할 수도 있다.
		
	
	13. 널(Null) 객체 패턴
			Null검사를 하는 코드가 있을 경우, null검사 코드를 누락하기 쉬우며 이는 NullPointerException을 발생시킬 우려가 있다.
			따라서 이를 막기 위해 null을 리턴하지 않고 null값을 대체하는 객체를 리턴함으로써 null검사코드를 없앨 수 있도록 한다.
			이 객체는 상위 타입을 상속받으며, 아무 기능도 수행하지 않는다.
			=> null검사 코드를 사용할 필요가 없기 때문에 코드가 간결해지고 가독성을 높여준다.			
		
		
	