
#Chapter 01. 들어가기
	1. 절차지향 -> 객체지향
	2. 수많은 IF~ELSE 반복문의 향연에서 벗어나라. 
		-> 클래스가 많이 생성되어 구조는 다소 복잡해졌지만, 요구사항의 변경시 유지보수가 용이해지며 유연한 구조를 갖게된다.


#Chapter 02. 객체지향
	1.절차지향
		문제점 - 새로운 요구사항의 발생으로 인한 수정 시, 한 곳을 수정하면 다른 곳에서 문제가 발생하는 악순환 발생
	
	2.객체지향
		프로그램의 규모가 작을 때에는 절차지향방식보다 복잡한 구조를 갖게된다.
		하지만, 객체지향에서는 해당 객체의 데이터를 변경하더라도 다른 객체에는 영향을 주지 않는다.
	
		인터페이스 - 객체를 사용하기 위한 일종의 명세나 규칙. 실제 객체가 기능을 어떻게 구현하는지에 대한 내용은 포함안함.
	
	3.객체의 책임과 크기
		객체가 제공하는 기능의 개수가 적다 -> 객체가 갖는 책임이 작다.
		한 객체에 기능이 많아지면 절차 지향적인 구조를 갖게된다. <--> 단일책임원칙(Single Responsibilty Principle; SRP)
		한 객체가 다른 객체를 생성하거나 다른 객체의 메소드를 호출할 때 => 의존
		
	4. 의존
		4.1 의존의 양면성
			a클래스 <-- b클래스 <-- c클래스 와 같은 의존의 경우,
			a클래스의 변경은 b와 c클래스에 영향을 주게된다.
	
	5. 캡슐화
		5.1 한 곳의 변화가 다른곳에 미치는 영향을 최소화한다.
			 내부 기능 구현이 변경되더라도 기능을 사용하는 코드는 영향을 받지 않도록 만들어준다.
		
		5.4 캡슐화를 위한 두 개의 규칙
			1. Tell, Don't Ask
				데이터를 물어보지 않고, 기능을 실행해라
				
			2. 데미테르의 법칙
				1. 메소드에서 생성한 객체의 메소드만 호출
				2. 파라미터로 받은 객체의 메소드만 호출
				3. 필드로 참조하는 객체의 메소드만 호출
				
				ex) public void processSome(Member menber){
						if(member.getDate().getTime() < ...){ //데미테르 법칙 위반
							...
						}
						
					}
				
				*데미테르의 법칙을 지키지 않는 전형적인 증상 2가지
					1. 연속된 get메소드 호출
					2. 임시 변수의 get 호출이 많음
				
			    **캡슐화는 내부 구현에 대해 유연함을 제공해준다.
			    
			    
#Chapter 03. 다형성과 추상타입		
	3.3 변화하는 부분을 추상화하기
		1. 변화되는 부분을 추상화하기
			=> 요구사항이 바뀔 때 변화하는 부분은 이후에도 변경될 소지가 많다.
				이를 추상타입으로 교체하면 향후 변경에 유연하게 대처 가능
			*추상화가 되어있지 않은 코드는 주로 동일 구조를 갖는 if-else블록으로 드러난다.
			
	3.4 인터페이스에 대고 프로그래밍하기
		1. 여기서의 인터페이스는 기능을 정의한 인터페이스를 사용하라는 의미
		추상화과정은 변화가 발생하는 곳에서부터 시작된다.
		하지만, 인터페이스를 사용할 때는 변화가능성이 높은 경우에 한해서 사용해야 한다.
		
	3.6 인터페이스와 테스트
		사용할 대상을 인터페이스로 추상화하면 만들 수 있는 
		Mock객체(가짜,모의)를 사용하여 테스트가 가능하다. (Mockito / jmock과 같은 프레임워크를 이용)
		

#Chapter 04. 재사용 : 상속보단 조립
	*객체지향의 주요 특징 : 상속을 통한 상위클래스의 메소드 재사용이 가능하다. 
		하지만 상위 클래스의 구현기능을 상속하여 사용할 경우 몇가지 문제점이 발생할 수 있다.
		
	1. 상속을 통한 재사용의 단점
		1.1 단점 1. 상위클래스 변경의 어려움
			어떤 클래스를 상속받는다 => 그 클래스에 의존한다
			계속되는 상위클래스의 상속은 모든 클래스들을 한 개의 거대한 단일구조처럼 만드는 결과를 초래.
			
		1.2 단점2.클래스의 불필요한 증가
			자바는 다중상속이 불가하기 때문에, 여러 기능의 조합이 필요한 경우 불필요하게 클래스가 계속 증가한다.
			 
		1.3 단점3.상속의 오용문제
			ex) ArrayList를 상속받은 Container라는 클래스에서 put이라는 메소드를 정의.
				put은 size를 정의한 하나의 ArrayList에서 사용됨. 
				하지만 개발자들이 put을 사용하지 않고, 직접적으로 ArrayList의 add메소드를 사용하여
				정의한 size를 초과하여 넣을 수 있게되는 문제가 발생할 수 있다.
			
	2. 위의 단점들의 해결방안 : 조립을 위한 재사용
		1.객체조립 : 여러 객체를 묶어서 더 복잡한 기능을 제공하는 객체를 만들어 내는 것
						조립을 이용하면 불필요한 클래스 증가를 방지
						ex) 필드에서 다른 객체를 참조하는 방식
		*조립을 통한 재사용의 단점 : 상대적으로 런타임 구조가 복잡해짐... 하지만 장점이 더 큼
		
		2.1 위임
			객체조립을 통해 다른객체에 처리를 위임시키는거 
			ex) 다른 객체에 위임한 후 메소드 요청
			
		2.2 그럼 상속은 대체 언제쓰냐 장점이 무엇인가
			상속을 사용할 때는 재사용이라는 관점이 아닌 기능의 확장 관점에서..
			+ 명확한 IS-A관계가 성립되어야 한다.
			=> 상위클래스의 기본기능은 기대로 유지하면서 하위로 내려갈수록 그 기능을 확장해나간다.
			ex) UI위젯
	

#Chapter 05. 설계 원칙: SOLID
	---------------------------------------------------------
	1. 단일 책임 원칙(Single Responsibility principle; SRP)
	2. 개방-폐쇄 원칙(Open-closed principle; OCP)
	3. 리스코프 치환 원칙(Liskov substitution principle; LSP)
	4. 인터페이스 분리 원칙(Interface segregation principle; ISP)
	5. 의존 역전 원칙(Dependency inversion principle; DIP)
	---------------------------------------------------------
	
	1. 단일 책임 원칙(Single Responsibility principle; SRP)
		클래스는 하나의 책임을 가져야 한다. 
		1.1 단일 책임 원칙 위반이 불러오는 문제점
			=> 읽어오는 데이터 타입의 변화 하나만으로 연쇄적으로 다른 코드의 변화도 야기시킨다. (ex. 데이터를 읽어오는 책임 / 화면에 뿌려주는 책임 두가지를 같이 갖고 있기 때문에)
		
		1.2 책임이란 변화에 대한 것
			서로 다른 이유로 바뀌는 책임들이 한 클래스에 함께 포함되어 있다면 이 클래스는 단일 책임 원칙을 어기고 있다.
			변화하는 부분 => 책임의 단위
		
		
	2. 개방-폐쇄원칙(Open-closed principle; OCP) //(?캡슐화와의 연관성)
		*확장에는 열려있어야 하고, 변경에는 닫혀있어야 한다.
			=> 기능을 변경/확장 할 수 있으면서, 그 기능을 사용하는 코드는 수정하지 않는다.
				=> 어떻게? : 추상화!! (***변화되는 부분을 추상화하여 변화를 고정시킨다.)
								또다른 방법은 상속! (변화되는 부분을 오버라이딩하여 하위클래스에서 기존 기능을 확장)
								
		2.1 개방 폐쇄 원칙이 깨질 때의 주요 증상
			1. 다운캐스팅
				다운캐스팅 후 실행하는 메소드가 변화대상인지 고려한 뒤, 객체마다 다르게 동작할 가능성이 높다면 이 메소드를 추상화하여야한다.
				
			2. 비슷한 if-else블록이 존재
				요구사항의 추가가 발생 시, 새로운 if-else블록이 생성 => 이를 막기 위해 바뀌는 부분을 추상화한 뒤 이를 사용하는 구조로 변경
			
			**변화가 예상되는 것을 추상화해서 변경의 유연함을 얻도록 해주자.
				변화가 발생하는 부분 => 추후에도 변화가 일어날 것 같은지 판단하는 능력... => 일어난다면 추상화 or 캡슐화 
			
			
	3. 리스코프 치환 원칙(Liskov substitution principle; LSP)
		**상위타입의 객체를 하위타입의 객체로 치환해도 상위타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
		***개방폐쇄원칙을 받쳐주는 다형성에 관한 원칙 => 상속을 사용해서 좋은지 나쁜지 판단할 때 LSP를 사용
		***LSP는 상속에 대해 엄격함을 적용하는 것. 올바른 상속이냐 라는 질문에 답을 해줄 수 있는 원칙
		***리스코프 치환 원칙이 왜 중요한가?
				1. 서브클래스 인스턴스를 파라미터로 전달 했을 때 메소드가 이상하게 작동 할 수 있다.
				2. 슈퍼클래스에 대해 작성된 단위테스트가 서브클래스에 대해서는 작동되지 않을 것이다.

		3.1 리스코프 치환 원칙을 지키지 않을 때의 문제
			ex)직사각형-정사각형 문제
			직사각형-정사각형은 ISA관계를 충족시키지만, 객체의 행위는 상호간의 일관성이 없다. 행위적으로 정사각형은 직사각형이 아니다.
		
		3.2 리스코프 치환 원칙은 기능의 명세와 확장에 대한 것
			*흔히 발생하는 위반 사례
				1. 명시된 명세에서 벗어난 값을 리턴
				2. 명시된 명세에서 벗어난 익셉션 발생
				3. 명시된 명세에서 벗어난 기능 수행
				
	//지금까지의 공통적인 이야기는  변화에 유연하게 대처할 수 있도록 설계하는 것이 중요하다.
		단일책임원칙을 바탕으로 변화나 요구사항이 추가되는 부분에서 
		이 변경으로 인해 야기될 수 있는 다른 곳의 변경을 최소화하여 기능 변경/확장을 쉽게 할 수 있도록 하는 것 뿐 아니라, 
		변경되는 부분이 추후에도 변경될 수 있는지에 대한 가능성을 캐치하는 능력을 키우고,
		만약 추후 변경가능성이 높다면 이를 추상화하여 변화를 고정시켜서 마찬가지로 향후 변경에 유연하게 대처가 가능하도록 해야한다.
		
		**타입을 확인하는 기능(ex. instanceof)을 사용하는 것은 전형적으로 리스코프 치환원칙을 어길때 발생하는 증상. => 하위타입을 대체할 수 없다는 뜻
			=> 이럴 때는 보통 추상화가 덜 되었기 때문이므로 요구사항의 변경이 발생한 부분을 판단하는 메소드를 상위타입에 추가하고 하위타입에서 재정의하여 리스코프 치환원칙을 지킬 수 있도록 한다.
		
		***리스코프 치환 원칙을 지키지 않으면 기능의 확장 시 점점 더 확장이 어렵게된다. 웬만하면 지키자.
	
	
	4. 인터페이스 분리 원칙(Interface segregation principle; ISP)
		*클라이언트는 자신이 사용하는 메소드에 의존해야 한다. => 클라이언트 입장에서 인터페이스를 분리하라!
		
		**자바에서는 JVM이 .class파일을 로딩하는 과정에서 링크과정이 동적으로 발생되기 때문에
		C++에서 발생하는 '사용하지 않는 인터페이스 변경에 의해 발생하는 소스 재컴파일' 문제가 발생하지는 않는다.
		하지만 용도에 맞게 인터페이스를 분리하는 것은 단일책임원칙과도 연결된다. 이게 잘 지켜져야만 재사용성도 높아지고 변경에 대한 여파도 최소화할 수 있다.
	
		각 클라이언트가 사용하는 기능을 중심으로 인터페이스를 분리해라... 결론은 기능관점에서 인터페이스를 설계해라. 라는 말..같다..
		
	5. 의존 역전 원칙(Dependency inversion principle; DIP)
		***저수준 모듈이 변경되더라도 고수준 모듈은 변경되지 않는 것.
		고수준 모듈이 저수준 모듈을 사용한다는 것은 고수준 모듈이 저수준 모듈에 의존적이 된다는 것인데, 어떻게 저수준이 고수준을 의존하게 만든다는걸까? => 추상화!!
		고수준과 저수준 모듈 모두가 추상화타입에 의존하게 함으로써, 고수준 모듈의 변경 없이 저수준 모듈을 변경할 수 있는 유연함을 갖게 된다.
		***이 때, 추상화 타입인 인터페이스는 고수준 모듈의 입장에서 만들어진다 => 저수준 모듈이 고수준 모듈에 의존하게 된다.
		***의존역전원칙은 리스코프 원칙과 함께 개방-폐쇄원칙의 기반이 되어준다.	  
		***하지만 소스코드는 의존적일지라도 런타임에서는 의존이 역전되지 않는다.
		
		5.4 의존역전원칙과 패키지
			타입의 소유도 역전시킨다.
			원래는 저수준 모듈이 타입을 소유하고 있었지만, 의존역전원칙을 적용함으로서 타입을 고수준 모듈이 소유하게 되고 이는 곧 독립적으로 배포할수 있도록 만들어준다,...?
			
			
			
	*****SOLID 원칙정리
	SOLID원칙을 한마디로 정의하면, 변화에 유연하게 대처할 수 있는 설계 원칙!
	
	*단일책임원칙과 인터페이스 분리 원칙은 객체가 커지지 않도록 막아주고 많은 기능을 갖지 않게 해준다 => 재사용성이 높아지고 기능 변경도 보다 용이해진다.
	*리스코프 치환원칙과 의존역전원칙은 개방폐쇄 원칙을 지원한다.
	*개방폐쇄 원칙은 변화되는 부분은 추상화 => 의존역전원칙
						/ 다형성(상속)을 이용하여 기능확장을 하면서도 기존코드를 수정하지 않도록 해준다. => 다형성을 도와주는 리스코프 치환 원칙
						
	
#Chapter 06. DI와 서비스 로케이터
	*소프트웨어가 크게 두 개의 영역으로 나뉘어진다.
		- 고수준 정책 및 저수준 구현을 포함한 어플리케이션 영역
		- 이 어플리케이션이 동작하도록 각 객체들을 연결해주는 메인 영역
		
	**메인영역
		어플리케이션 영역에서 사용될 객체를 생성한다.
		각 객체 간의 의존관계를 설정한다.
		어플리케이션을 실행한다.
		=> 메인영역은 어플리케이션 영역에 의존적이다.
			어플리케이션에서 사용할 객체를 교체하기 위해 메인 영역의 코드를 수정하는 것은 어플리케이션영역에는 어떠한 영향도 끼치지 않는다.
			
		
		2. DI를 이용한 의존 객체 사용
			*콘크리트 클래스를 직접 사용해서 객체생성 => 의존역전원칙 위반 => 확장 폐쇄원칙 위반 => 변화에 경직된 코드
			*서비스 로케이터를 사용 시, 서비스 로케이터를 통해서 의존객체를 찾게 되는데...단점이 존재한다. 뒤에서 설명.
			
			=> 이러한 단점을 보완한 것이 DI이다. 
			필요한 객체를 직접 생성하거나 찾지 않고 외부에서 넣어주는 방식
			
			DI를 통해서 의존객체를 관리할 때는 객체를 생성하고 각 객체들을 의존관계에 따라 연결해 주는 조립기능이 필요하다.
			=> Spring framework가 바로 객체를 생성하고 조립해주는 기능을 제공하는 DI 프레임워크이다.
			
			2.1 생성자 방식과 설정메소드 방식
				**의존하는 객체를 전달받을 수 있는 두 가지 방식 
					1) 생성자방식
						- 생성자를 통해서 의존객체를 전달받는 방식으로서, 전달받은 객체를 필드에 보관한 뒤 메소드에서 사용
					
					2) 설정메소드 방식
						- 메소드를 이용해서 의존객체를 전달받는다. 
						- 파라미터로 전달받은 의존객체를 필드에 보관한 뒤, 다른메소드에서는 필드를 사용해서 의존객체의 기능을 실행
						
				*의존객체 주입이 완료되면, 조립기는 생성자와 설정메소드를 이용해서 의존객체를 알아서 전달
			   
			  ***각 방식의 장단점
			  	*생성자방식
			  		- 객체를 생성하는 시점에 필요한 모든 의존객체를 준비할 수 있으며 의존객체가 정상인지 확인할 수 있다.
			  		- 의존 객체가 먼저 생성되어 있어야 한다.
				
				*설정메소드 방식
					- 객체를 생성한 뒤에 의존객체를 주입한다.
					- 객체가 나중에 생성된다면 설정메소드방식을 사용해야 한다.
					- 의존할 객체가 많을 경우,메소드 이름을 통해 코드 가독성을 높일 수 있다.
					
			2.2 DI와 테스트
				***DI는 의존 객체를 Mock객체로 쉽게 대체할 수 있도록 도와서 쉬운 단위테스트가 가능하다.
				 
			2.3 스프링 프레임워크 예
				*대표적 DI 프레임워크
				생성자 방식과 설정 메소드 방식을 모두 지원하며 XML파일을 이용하여 객체생성과 조립을 설정한다.
				스프링 3.x버전부터는 XML파일을 자바 코드 기반으로 설정할 수도 있다.
				
		3. 서비스 로케이터를 이용한 의존 객체 사용
			**안드로이드 같은 환경적 제약으로 인해 DI패턴을 적용할 수 없는 경우 서비스 로케이터를 사용하여 의존객체를 사용한다.
				
			3.1 서비스 로케이터의 구현
				*ServiceLocator - 어플리케이션에서 필요로하는 객체를 제공하는 책임을 갖는다.
										의존대상이 되는 객체별로 제공메소드를 정의한다. 의존객체가 필요한 곳에서 메소드를 이용하여 필요한 객체를 구한 뒤 기능 실행한다.
										서비스로케이터는 어플리케이션 영역에 위치하게 되며, 
										메인영역에서는 서비스 로케이터가 제공할 객체를 생성하고 이 객체를 이용해서 서비스 로케이터를 초기화 해준다.
			
			*객체등록방식의 서비스 로케이터 구현
				서비스 로케이터 생성할 때 사용할 객체를 전달한다.
				인스턴스를 지정하고 참조하기 위한 static 메소드를 제공한다.
				
				












	
					   
		
			
		
		
		
	
	