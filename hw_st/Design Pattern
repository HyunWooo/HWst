
#Chapter 01. 들어가기
	1. 절차지향 -> 객체지향
	2. 수많은 IF~ELSE 반복문의 향연에서 벗어나라. 
		-> 클래스가 많이 생성되어 구조는 다소 복잡해졌지만, 요구사항의 변경시 유지보수가 용이해지며 유연한 구조를 갖게된다.


#Chapter 02. 객체지향
	1.절차지향
		문제점 - 새로운 요구사항의 발생으로 인한 수정 시, 한 곳을 수정하면 다른 곳에서 문제가 발생하는 악순환 발생
	
	2.객체지향
		프로그램의 규모가 작을 때에는 절차지향방식보다 복잡한 구조를 갖게된다.
		하지만, 객체지향에서는 해당 객체의 데이터를 변경하더라도 다른 객체에는 영향을 주지 않는다.
	
		인터페이스 - 객체를 사용하기 위한 일종의 명세나 규칙. 실제 객체가 기능을 어떻게 구현하는지에 대한 내용은 포함안함.
	
	3.객체의 책임과 크기
		객체가 제공하는 기능의 개수가 적다 -> 객체가 갖는 책임이 작다.
		한 객체에 기능이 많아지면 절차 지향적인 구조를 갖게된다. <--> 단일책임원칙(Single Responsibilty Principle; SRP)
		한 객체가 다른 객체를 생성하거나 다른 객체의 메소드를 호출할 때 => 의존
		
	4. 의존
		4.1 의존의 양면성
			a클래스 <-- b클래스 <-- c클래스 와 같은 의존의 경우,
			a클래스의 변경은 b와 c클래스에 영향을 주게된다.
	
	5. 캡슐화
		5.1 한 곳의 변화가 다른곳에 미치는 영향을 최소화한다.
			 내부 기능 구현이 변경되더라도 기능을 사용하는 코드는 영향을 받지 않도록 만들어준다.
		
		5.4 캡슐화를 위한 두 개의 규칙
			1. Tell, Don't Ask
				데이터를 물어보지 않고, 기능을 실행해라
				
			2. 데미테르의 법칙
				1. 메소드에서 생성한 객체의 메소드만 호출
				2. 파라미터로 받은 객체의 메소드만 호출
				3. 필드로 참조하는 객체의 메소드만 호출
				
				ex) public void processSome(Member menber){
						if(member.getDate().getTime() < ...){ //데미테르 법칙 위반
							...
						}
						
					}
				
				*데미테르의 법칙을 지키지 않는 전형적인 증상 2가지
					1. 연속된 get메소드 호출
					2. 임시 변수의 get 호출이 많음
				
			    **캡슐화는 내부 구현에 대해 유연함을 제공해준다.
			    
			    
#Chapter 03. 다형성과 추상타입		
	3.3 변화하는 부분을 추상화하기
		1. 변화되는 부분을 추상화하기
			=> 요구사항이 바뀔 때 변화하는 부분은 이후에도 변경될 소지가 많다.
				이를 추상타입으로 교체하면 향후 변경에 유연하게 대처 가능
			*추상화가 되어있지 않은 코드는 주로 동일 구조를 갖는 if-else블록으로 드러난다.
			
	3.4 인터페이스에 대고 프로그래밍하기
		1. 여기서의 인터페이스는 기능을 정의한 인터페이스를 사용하라는 의미
		추상화과정은 변화가 발생하는 곳에서부터 시작된다.
		하지만, 인터페이스를 사용할 때는 변화가능성이 높은 경우에 한해서 사용해야 한다.
		
	3.6 인터페이스와 테스트
		사용할 대상을 인터페이스로 추상화하면 만들 수 있는 
		Mock객체(가짜,모의)를 사용하여 테스트가 가능하다. (Mockito / jmock과 같은 프레임워크를 이용)
		

#Chapter 04. 재사용 : 상속보단 조립
	*객체지향의 주요 특징 : 상속을 통한 상위클래스의 메소드 재사용이 가능하다. 
		하지만 상위 클래스의 구현기능을 상속하여 사용할 경우 몇가지 문제점이 발생할 수 있다.
		
	1. 상속을 통한 재사용의 단점
		1.1 단점 1. 상위클래스 변경의 어려움
			어떤 클래스를 상속받는다 => 그 클래스에 의존한다
			계속되는 상위클래스의 상속은 모든 클래스들을 한 개의 거대한 단일구조처럼 만드는 결과를 초래.
			
		1.2 단점2.클래스의 불필요한 증가
			자바는 다중상속이 불가하기 때문에, 여러 기능의 조합이 필요한 경우 불필요하게 클래스가 계속 증가한다.
			 
		1.3 단점3.상속의 오용문제
			ex) ArrayList를 상속받은 Container라는 클래스에서 put이라는 메소드를 정의.
				put은 size를 정의한 하나의 ArrayList에서 사용됨. 
				하지만 개발자들이 put을 사용하지 않고, 직접적으로 ArrayList의 add메소드를 사용하여
				정의한 size를 초과하여 넣을 수 있게되는 문제가 발생할 수 있다.
			
	2. 위의 단점들의 해결방안 : 조립을 위한 재사용
		1.객체조립 : 여러 객체를 묶어서 더 복잡한 기능을 제공하는 객체를 만들어 내는 것
						조립을 이용하면 불필요한 클래스 증가를 방지
						ex) 필드에서 다른 객체를 참조하는 방식
		*조립을 통한 재사용의 단점 : 상대적으로 런타임 구조가 복잡해짐... 하지만 장점이 더 큼
		
		2.1 위임
			객체조립을 통해 다른객체에 처리를 위임시키는거 
			ex) 다른 객체에 위임한 후 메소드 요청
			
		2.2 그럼 상속은 대체 언제쓰냐 장점이 무엇인가
			상속을 사용할 때는 재사용이라는 관점이 아닌 기능의 확장 관점에서..
			+ 명확한 IS-A관계가 성립되어야 한다.
			=> 상위클래스의 기본기능은 기대로 유지하면서 하위로 내려갈수록 그 기능을 확장해나간다.
			ex) UI위젯
	

#Chapter 05. 설계 원칙: SOLID
	---------------------------------------------------------
	1. 단일 책임 원칙(Single Responsibility principle; SRP)
	2. 개방-폐쇄 원칙(Open-closed principle; OCP)
	3. 리스코프 치환 원칙(Liskov substitution principle; LSP)
	4. 인터페이스 분리 원칙(Interface segregation principle; ISP)
	5. 의존 역전 원칙(Dependency inversion principle; DIP)
	---------------------------------------------------------
	
	1. 단일 책임 원칙(Single Responsibility principle; SRP)
		클래스는 하나의 책임을 가져야 한다. 
		1.1 단일 책임 원칙 위반이 불러오는 문제점
			=> 읽어오는 데이터 타입의 변화 하나만으로 연쇄적으로 다른 코드의 변화도 야기시킨다. (ex. 데이터를 읽어오는 책임 / 화면에 뿌려주는 책임 두가지를 같이 갖고 있기 때문에)
		
		1.2 책임이란 변화에 대한 것
			서로 다른 이유로 바뀌는 책임들이 한 클래스에 함께 포함되어 있다면 이 클래스는 단일 책임 원칙을 어기고 있다.
			변화하는 부분 => 책임의 단위
		
	2. 개방-폐쇄원칙(Open-closed principle; OCP) //(?캡슐화와의 연관성)
		*확장에는 열려있어야 하고, 변경에는 닫혀있어야 한다.
			=> 기능을 변경/확장 할 수 있으면서, 그 기능을 사용하는 코드는 수정하지 않는다.
				=> 어떻게? : 추상화!! (***변화되는 부분을 추상화하여 변화를 고정시킨다.)
								또다른 방법은 상속! (변화되는 부분을 오버라이딩하여 하위클래스에서 기존 기능을 확장)
								
		2.1 개방 폐쇄 원칙이 깨질 때의 주요 증상
			1. 다운캐스팅
				다운캐스팅 후 실행하는 메소드가 변화대상인지 고려한 뒤, 객체마다 다르게 동작할 가능성이 높다면 이 메소드를 추상화하여야한다.
				
			2. 비슷한 if-else블록이 존재
				요구사항의 추가가 발생 시, 새로운 if-else블록이 생성 => 이를 막기 위해 바뀌는 부분을 추상화한 뒤 이를 사용하는 구조로 변경
			
			**변화가 예상되는 것을 추상화해서 변경의 유연함을 얻도록 해주자.
				변화가 발생하는 부분 => 추후에도 변화가 일어날 것 같은지 판단하는 능력... => 일어난다면 추상화 or 캡슐화 
			
	3. 리스코프 치환 원칙(Liskov substitution principle; LSP)
		**상위타입의 객체를 하위타입의 객체로 치환해도 상위타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
		***개방폐쇄원칙을 받쳐주는 다형성에 관한 원칙 => 상속을 사용해서 좋은지 나쁜지 판단할 때 LSP를 사용
		***LSP는 상속에 대해 엄격함을 적용하는 것. 올바른 상속이냐 라는 질문에 답을 해줄 수 있는 원칙
		***리스코프 치환 원칙이 왜 중요한가?
				1. 서브클래스 인스턴스를 파라미터로 전달 했을 때 메소드가 이상하게 작동 할 수 있다.
				2. 슈퍼클래스에 대해 작성된 단위테스트가 서브클래스에 대해서는 작동되지 않을 것이다.

		3.1 리스코프 치환 원칙을 지키지 않을 때의 문제
			ex)직사각형-정사각형 문제
			직사각형-정사각형은 ISA관계를 충족시키지만, 객체의 행위는 상호간의 일관성이 없다. 행위적으로 정사각형은 직사각형이 아니다.
		
		3.2 리스코프 치환 원칙은 기능의 명세와 확장에 대한 것
			*흔히 발생하는 위반 사례
				1. 명시된 명세에서 벗어난 값을 리턴
				2. 명시된 명세에서 벗어난 익셉션 발생
				3. 명시된 명세에서 벗어난 기능 수행
				
	//지금까지의 공통적인 이야기는  변화에 유연하게 대처할 수 있도록 설계하는 것이 중요하다.
		단일책임원칙을 바탕으로 변화나 요구사항이 추가되는 부분에서 
		이 변경으로 인해 야기될 수 있는 다른 곳의 변경을 최소화하여 기능 변경/확장을 쉽게 할 수 있도록 하는 것 뿐 아니라, 
		변경되는 부분이 추후에도 변경될 수 있는지에 대한 가능성을 캐치하는 능력을 키우고,
		만약 추후 변경가능성이 높다면 이를 추상화하여 변화를 고정시켜서 마찬가지로 향후 변경에 유연하게 대처가 가능하도록 해야한다.
		
		
		
			














	
					   
		
			
		
		
		
	
	