Chapter1. 클린 코드
	1.3 나쁜 코드로 치르는 대가
		중복을 피하라
		한 기능만 수행하라
		제대로 표현하라
		간단하게 추상화하라
	
	1.6 보이스카우트 규칙
		캠프장은 처음 왔을때보다 더 깨끗하게 해놓고 떠나라!
		
		
Chapter2. 의미있는 이름
	2.2 의도를 분명히 밝혀라
		변수/함수/클래스에 따로 주석이 필요하다면 의도를 분명히 드러내지 못한거다.
		=> 명시적이어야 한다.
	
	2.3 그릇된 정보를 피하라
		실제로 List가 아니라면 ~~List로 명명하지 않는다. => ~~Group같은걸로..
		
	2.4 의미있게 구분하라
		연속적인 숫자를 덧붙인 이름은 의도적인 의름과 정반대다. 아무런 정보를 제공하지 못하는 이름...
		읽는 사람이 차이를 알 수 있도록 이름을 지어라.
		
	2.5 발음하기 쉬운 이름을 사용하라
	2.6 검색하기 쉬운 이름을 사용하라
		변수나 상수를 코드 여러 곳에서 사용한다면 검색하기 쉬운 이름이 바람직하다.
	
	2.7 인코딩을 피하라
	2.9 클래스 이름
		클래스 이름과 객체 이름은 명사나 명사구가 적합. 동사는 사용하지 않는다.
		
	**2.10 메소드 이름
		동사나 동사구가 적합하다.
		조건자는 앞에 is를 붙인다.
		
	**생성자를 중복해 정의할 때는 정적 팩토리 메소드를 사용한다. 메소드는 인수를 설명하는 이름을 사용한다.
		이런식으로 factory method 를 만들 때는 항상 naming 을 고려해야 한다. 잘못된 naming 으로 확장한 static factory method 는 오히려 혼란을 줄 수도 있다.
			
			
	2.12 개념 하나에 단어 하나를 사용하라
		일관성 있는 어휘가 필요하다.
		메소드 이름은 일관적이고 독자적이어야한다. 그래야 주석을 뒤져보지 않고도 올바른 메소드를 선택할 수 있다.
	
		
Chapter3. 함수
	3.2 작게 만들어라
		함수는 한가지를 해야한다. 읽고 이해하기 쉬어야 한다.
		=> 함수가 '한가지'만 하는지 판단하는 방법 => 의미 있는 이름으로 다른함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 함수이다.
		
	3.5 서술적인 이름을 사용하라
		코드를 읽으며 짐작했던 기능을 그대로 수행한다면 클린코드..
		짧고 어려운 이름보다 길고 서술적인 이름이 더 낫다.
	
	***3.6 함수 인수
		플래그 인수
			 - 플래그 인수는 추하다... 함수가 한꺼번에 여러가지를 처리한다고 대놓고 공표하는것...
			 
	3.8 명령과 조회를 분리하라
	3.9 오류코드보다 예외를 사용하라
		*Try/Catch 대신 예외를 던져라...
		  정상적인 동작과 오류처리 동작을 분리하면 코드를 이해하고 수정하기 쉬워진다...
		  
	3.10 반복하지 마라
		중복은 소프트웨어에서 악의 근원...
		
	3.12 함수를 어떻게 짜죠?
		처음부터 클린한 코드는 없다. 끊임없이 수정!
		
	3.13 결론
		
		
Chapter4. 주석
	4.1 주석은 나쁜 코드를 보완하지 못한다.
		주석 쓸 시간에 코드를 깔끔히 고쳐라
		
	4.2 코드로 의도를 표현하라
		몇 초만 더 생각하면 코드로 대다수 의도를 표현할 수 있다.
		
	4.3 좋은 주석
		1. 법적인 주석
			저작권.. 소유권...
			
		2. 정보제공주석
		3. 의도를 설명하는 주석
		4. 의미를 명료하게 밝히는 주석
		5. 결과를 경고하는 주석 => @Ignore로 대체 가능
		6. TODO주석
			- 앞으로 할 일을 남기는 주석
		7. 중요성을 강조하는 주석
		
	4.4 나쁜 주석
		1. 주절거리는 주석 - 바이트를 낭비할 뿐
		2. 이야기를 중복하는 주석
		3. 오해할 여지가 있는 주석
		...다 쓰지 말아야 할것들에 대한 예시..
		
	
Chapter5. 형식 맞추기
	5.1 형식을 맞추는 목적
		***맨 처음 잡아놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속해서 영향을 미친다.
		원래 코드는 사라질지라도 개발자의 스타일과 규율은 사라지지 않는다.
		
	5.2 적절한 행 길이를 유지하라
		좋은 신문 기사처럼 작성해라
		**개념은 빈 행으로 분리하라
		**호출되는 함수를 호출하는 함수보다 나중에 배치 => 고차원에서 저차원으로 자연스럽게 내려감
		
	5.3 가로 형식 맞추기
		*항 사이에는 공백이 들어간다.
		
	5.4 팀 규칙
		팀이 정한 규칙을 잘 따라라
		들여쓰기 잘해라
		

Chapter6. 객체와 자료 구조
	6.1 자료 추상화
		자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 낫다.
		
	6.2 자료/객체 비대칭
		객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.
		자료구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.
		
		=> (자료구조를 사용하는) 절차적 코드는 기존 함수를 변경하지 않으면서 새 함수를 추가하기 쉽다. <-> 절차적코드는 새로운 자료 구조를 추가하기 어렵다.
			객체지향코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다. <-> 새로운 함수를 추가하기 어렵다.
			
		*** 객체지향코드에서 어려운 변경은 절차적 코드에서 쉬우며, 절차적 코드에서 어려운 변경은 객체 지향 코드에서 쉽다.
		
	6.3 디미터 법칙
		=> 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다.
	
	6.4 자료 전달 객체
		자료 구조체의 전형적인 형태 => DTO
		빈 구조는 private변수를 조회/설정 함수로 조작한다.
		
		*활성레코드
			활성레코드는 DTO의 특수한 형태.
			공개변수가 있거나  private변수에 조회/설정 함수가 있는 자료 구조.
			=> 활성 레코드는 자료구조로 취급해야한다. 객체XXX
				 비즈니스 규칙을 담으면서 내부자료를 숨기는 객체는 따로 생성한다.	
	

Chapter7. 오류 처리
	7.2 Try-Catch-Finally문부터 작성하라
	7.3 미확인 예외를 사용해라
		확인된 예외는 반드시 필요하지 않다. => 확인된 예외는 OCP를 위반한다.
		*=> 최하위함수를 변경하여 새로운 오류가 발생 시, 최상위 단계까지 throws경로의 연쇄수정이 일어난다.
				또한, 모든 함수가 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화가 깨진다.
				
	7.4 예외에 의미를 제공하라
		호출 스택만으로는 예외의 의미를 알기 어렵다. catch블록에서 오류를 기록하도록 충분한 정보를 넘겨라.
	
	7.5 호출자를 고려해 예외 클래스를 정의하라
	7.6 정상흐름을 정의하라
	7.7 null을 반환하지 마라
		누구 하나라도 null 확인을 누락한다면 NullPointerException이 발생할 것이다.
	7.8 null을 전달하지 마라
		애초에 null을 넘기지 못하도록 금지해라
				

Chapter8. 경계
	소프트웨어 경계를 깔끔하게 처리하는 기법과 기교를 살펴본다.
	
	8.1 외부 코드 사용하기
		Map 또는 유사한 경계 인터페이스를 여기저기 넘기지 말라.
		Map 인스턴스를 공개 API의 인수로 넘기거나 반환 값으로 사용하지 않는다.
	
	8.2 경계 살피고 익히기
		학습테스트 : 프로그램에서 사용하려는 방식대로 외부API를 호출한다.
		통제된 환경에서 API를 제대로 이해하는지 확인하는 셈이다.
		
	8.3  Log4j 익히기
	
	8.4 학습 테스트는 공짜 이상이다
	8.5 아직 존재하지 않는 코드를 사용하기
	8.6 클린 경계
		이쪽 코드에서 외부 패키지를 세세하게 알아야 할 필요가 없다.
		통제불가능한 외부패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 낫다.
		새로운 클래스로 경계를 감싸거나, 어댑터 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자.
		가독성과 코드의 일관성, 변경할 코드도 줄어든다.
		

Chapter9. 단위테스트		
	9.1 TDD법칙 3가지
		1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
		2. 컴파일은 성공하고 실행이 실패하는 정도로만 테스트를 작성
		3. 현재 실패하는 테스트를 통과할 정도로만 실제코드를 작성
		
	9.2 클린 테스트 코드 유지하기
		지저분한 테스트코드를 유지할 바에는 그냥 테스트코드 만들지 마라.
		=> 실제코드 못지않게 깨끗하게 짜야 한다.
		
		**단위테스트는 코드에 유연성, 유지보수성, 재사용성을 제공한다..
		
	9.3 클린 테스트 코드
		클린 테스트 코드 => ***가독성**********
		테스트 코드는 최소의 표현으로 많은 것을 나타내야 한다.
		**이중표준 
			StringBuffer는 보기에 흉하다... 하지만 실 환경은 자원과 메모리가 제한적일 가능성이 있다..
		
	9.4 테스트 당 assert 하나
		테스트 당 개념 하나
	
	9.5 FIRST
		F : Fast => 테스트는 빨라야 한다.
		I : Independent => 각 테스트는 독립적이어야 한다.
		R : Repeatable => 테스트는 어떤 환경에서도 반복이 가능해야 한다.
		S : Self-Validating => 테스트는 Bool값으로 결과를 내야한다.
		T : Timely => 테스트는 실제 코드를 구현하기 직전에 구현한다.
		
	9.6 결론
		테스트코드를 깔끔하게 유지하라!!
		

Chapter10. 클래스
	10.2 클래스는 작아야 한다
		*단일책임원칙
			 - 클래스나 모듈을 변경할 이유가 단 하나뿐이어야 한다는 원칙
			 => 큰 클래스 몇개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 바람직하다.
		
		*응집도
			- 클래스는 인스턴스 변수 수가 작아야 한다.
			- 클래스가 응집력을 잃는다면 쪼개라


Chapter11. 시스템
	11.3 확장
		처음부터 올바르게 구현한 시스템은 없다. 매일 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다.
		*횡단관심사 - 영속성 프레임워크는 모듈화할 수 있다.
		AOP - 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법론
	..보다 넘김
	
	
Chapter12. 창발성
	12.1 창발적 설계로 깔끔한 코드를 구현하자
		켄트백 아저씨는 간단한 설계 규칙 네 가지가 소프트웨어 설계 품질을 크게 높여준다고 한다.
		1. 모든 테스트를 실행한다.
		2. 중복을 없앤다.
		3. 프로그래머 의도를 표현한다.
		4. 클래스와 메소드 수를 최소로 줄인다.
		
	12.2 간단한 설계규칙 1: 모든 테스트를 실행하라
		계속 테스트를 하다 보면 시스템은 낮은 결합도와 높은 응집력이라는, 객체지향방법론이 지향하는 목표를 저절로 달성한다. 설계품질도 덩달아 업~!
		
	12.3 간단한 설계규칙 2-4: 리팩토링
		
	12.4 중복을 없엔다.
		작은 재사용은 시스템 복잡도를 극적으로 줄여준다.
		고차원 중복 제거 목적 : 템플릿 메서드 패턴
		
	12.5 표현하라
		우선, 좋은 이름을 선택한다.
		함수와 클래스 크기를 가능한 줄인다.
		조금만 더 주의를 기울이고 자신의 작품을 더 자랑하자
		
					
Chapter13. 동시성
	여러 스레드를 동시에 돌리는 이유를 논해보자

	13.1 동시성이 필요한 이유
		*동시성은 결합을 없애는 전략
			무엇(What)과 언제(When)를 분리하는 전략
			스레드가 하나인 프로그램은 무엇과 언제가 서로 밀접하다.
			이를 분리하면 구조와 효율이 극적으로 나아진다.
				
	13.2 
	
		